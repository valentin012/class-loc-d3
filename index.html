<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Class-loc-d3 by valentin012</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <style>

#map {
  width: 1200px;
  height: 750px;
  overflow: hidden;
  margin: 0;
  padding: 0;
  float: left;
}

#control {
  overflow: hidden;
  padding: 20px;
  margin: 5px;
}

select {
    margin-right: 10px;
    margin-top: 5px;
    width: 180px;
}


.links {
  //width: 100%;
  //height: 100%;

 position: absolute;
}

.stations, .stations svg, .student_layer, .student_layer svg {
  position: absolute;
}

.stations svg{
  //width: 18px; 
  //height: 18px;
  font: 10px sans-serif;

}

.student_layer svg {
  width: 12px; 
  height: 12px;
  font: 10px sans-serif;
}

.stations circle:hover {
    fill: #fce57e;
    cursor: pointer;
}

.students circle:hover {
    fill: lightgreen;
}

.stations circle {
  stroke: black;
  stroke-width: 1px;
}

.marker circle {
  stroke: black;
  stroke-width: 1px;
  //opacity: 0.6;
}

.students circle {
  fill: green;
  stroke: black;
  stroke-width: 1px;
  
}


div.tooltip {	
    position: absolute;			
    text-align: center;			
    width: 90px;					
    height: 16px;					
    padding: 2px;				
    font: 12px sans-serif;		
    background: lightsteelblue;	
    border: 0px;		
    border-radius: 8px;			
    pointer-events: none;
}

</style>
<script src="//maps.google.com/maps/api/js?key=AIzaSyA3FkcyyXRegJ1v7jNfQ0KjuS2BqZPxZis&sensor=true"></script>
<script src="javascripts/d3.min.js"></script>


    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>D3 Visualization tool (Class-loc-d3)</h1>
        <p></p>

        <p class="view"><a href="https://github.com/valentin012/class-loc-d3">View the Project on GitHub <small>valentin012/class-loc-d3</small></a></p>


        <ul>
          <li><a href="https://github.com/valentin012/class-loc-d3/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/valentin012/class-loc-d3/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/valentin012/class-loc-d3">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p> This tool visualizes the estimated class locations from students' bluetooth and location data. Note, that we show here NOT the original data. This data was randomly generated for visualization purposes.
        </p>
<div id="control">
<label> <input type="checkbox" name="radius" value="radius" id="radius" onclick="updateRadius();"> 200m radius </label>
</div>
<div id="map"></div>





      </section>
     
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
    <script>


var usercolor = d3.scale.category10().domain(d3.range(1000));

function getColorForUser(d) {

    if (!("id" in d.value)) {
                 return usercolor(d.value['user']);                
            } else {
                return 'red';
            }
};

var cluster_overlay = null;
var student_overlay = null;
//var student_locs_overlay = null;


// Create the Google Map…
var map = new google.maps.Map(d3.select("#map").node(), {
  zoom: 16,
  center: new google.maps.LatLng(55.784875, 12.521238),
  mapTypeId: google.maps.MapTypeId.ROADMAP 
});

var cluster_data;
var locations;
// Load the station data. When the data comes back, create an overlay.
d3.csv("data/dummy_cluster.csv", function(error, data) {
  if (error) throw error;
 
    cluster_data = data;

    
    
    cluster_overlay = new google.maps.OverlayView();
    student_overlay = new google.maps.OverlayView();
   
});


var student_entries;


d3.csv("data/dummy_locs.csv", function(error, data) {
  if (error) throw error;
 
    locations = data;   
    var course_set = new Set();
    data.forEach(function(d) {
        course_set.add(d['course'] + ' (' + d['term'] + ')');
    });
    
    
    var course_dict = {};
    var course_user = {};
    course_set.forEach(function(d) {
        course_dict[d] = new Array();
        course_user[d] = new Set();
    });
    
    locations.forEach(function(d) {
        course_user[d['course'] + ' (' + d['term'] + ')'].add(d['date']);
    });
    
    
    course_set.forEach(function(d) {
        course_user[d].forEach(function(dd) {
            var option = document.createElement("option");
            option.text = dd;
            option.value = dd;
            course_dict[d].push(option);
            
        });

    });
    console.log(course_set);
    
    var combo =document.createElement("select");
    combo.id = 'course_combo';    
    
    
    var entries = Array.from(course_set);
    entries.sort();
    entries.forEach(function(d) {
    var option = document.createElement("option");
        option.text = d;
        option.value = d;
        combo.add(option,null);
        });
    combo.addEventListener("change", selectCourse);
    combo.addEventListener("keyup", selectCourse);
    document.getElementById('control').appendChild(combo);
    
    combo =document.createElement("select");
    combo.id = 'date_combo';
    combo.addEventListener("change", selectDate);
    combo.addEventListener("keyup", selectDate);
    document.getElementById('control').appendChild(combo);
    
    
    
    student_entries = course_dict;
    
});

//var layer;
var cluster_circle = [];

function selectCourse(sel) {
    console.log(this.value);
    val =  this.value;
    
    var combo = document.getElementById("date_combo");
    
    var length = combo.options.length;
        for (i = 0; i < length; i++) {
          combo.options[i] = null;
        }
    
    combo.options.length = 0;
    
       
    var option = document.createElement("option");
    option.text = "All";
    option.value = "All";
    combo.add(option,null);
            
       
    
    student_entries[val].forEach(function(d) {        
        combo.add(d,null);
        });
    
    
    student_overlay.setMap(null);
    cluster_overlay.setMap(null);
    combo.options[0].selected = 'selected';
    selectDate(null);
};

function getColorForNode(d) {
    if (!("id" in d.value)) {
                return 'blue';
            } else {
                return 'red';
            }
};

function selectDate(sel) {
    
    var val =  document.getElementById("date_combo").value;
    var selected_key = document.getElementById("course_combo").value;
    
    console.log(val);
    
    student_overlay.setMap(null);
    cluster_overlay.setMap(null);
    
    var dataset = new Array();
    
    if(val == 'All') {
    cluster_data.forEach(function(d) {
    
        key = d['course'] + ' (' + d['term'] + ')'
            if(key == selected_key) {
                
                dataset.push(d);
            }
       });
    
    
    }
    else {
    
    cluster_data.forEach(function(d) {
    
        key = d['course'] + ' (' + d['term'] + ')'
            if((key == selected_key) && (d['date'] == val)) {
                
                dataset.push(d);
            }
       });
       
       
    locations.forEach(function(d) {
            key = d['course'] + ' (' + d['term'] + ')' 
            if((d['date'] == val) && (key == selected_key)){
                
                dataset.push(d);
            }
       });
       
       }
       
    var date_time = {}
    
    var lines = new Array();
       
    dataset.forEach(function(d) {
        key = d['date'] + " " + d['time']
        if (!(key in date_time)) {
            date_time[key] = d;
        } else {
            p1 = date_time[key];
            var l = new Object();
            l['x1'] = p1['lon'];
            l['y1'] = p1['lat'];
            l['x2'] = d['lon'];
            l['y2'] = d['lat'];
            
            lines.push(l);
            
            
        }
    
    
    });
       

    cluster_overlay.onRemove = function() {
        cluster_circle.forEach(function(cl) {
            cl.setMap(null);
            cl = null;
        });
        cluster_circle = [];
        d3.selectAll('svg').filter('.marker').remove();
    };

  // Add the container when the overlay is added to the map.
  cluster_overlay.onAdd = function() {
    var layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
        .attr("class", "stations");

    // Draw each marker as a separate SVG element.
    // We could use a single SVG, but what size would it have?
    cluster_overlay.draw = function() {
    var projection = cluster_overlay.getProjection();

      //var padding = 6;  //6  // 9

      var marker = layer.selectAll("svg").filter('.marker')
          .data(d3.entries(dataset))
          .each(transform) // update existing markers
        .enter().append("svg")
          .each(transform)
          .attr("class", "marker")
          ;
          
    /*  
    var markerLink = layer.selectAll(".links")
      .data(lines)
      .each(pathTransform) // update existing markers       
    .enter().append("svg:svg")
     .attr("class", "links")
      .each(pathTransform);
      */
      
     var div = d3.select("body").append("div")	
            .attr("class", "tooltip")				
            .style("opacity", 0); 

      
      // Add a circle.
      marker.append("circle")
          .attr("r", function(d) {
            if (!("id" in d.value)) {
                return 5;
            } else {
                return 14;
            }
          }) //5  //
          .attr("cx", function(d) {
            if (!("id" in d.value)) {
                return 6;
            } else {
                return 15;
            }
          })
          .attr("cy",function(d) {
            if (!("id" in d.value)) {
                return 6;
            } else {
                return 15;
            }
          })
          .style("fill",function(d) {
            return getColorForUser(d);
          })
          .style("opacity",function(d) {
            if (!("id" in d.value)) {
                return 0.9;
            } else {
                return 0.6;
            }
          })
        .on("mouseover", function(d) {	
            
            d3.select(this).style("fill","lightblue");
            
            var le = (d3.event.pageX + 30);
            var to = (d3.event.pageY - 60);
            if (!("id" in d.value)) {
                le = (d3.event.pageX + 12);
                to = (d3.event.pageY - 24);
            } 
            
            var txt = d.value['user'] + " (" + d.value['time'] + ")";
            if ("id" in d.value) {
                txt = d.value['time'];
            }
            
            div.transition()		
                .duration(200)		
                .style("opacity", .8);		
            div	.html(txt)	
                .style("left", le + "px")		//12
                .style("top", to + "px");	//24
            })				
        .on("mouseout", function(d) {
            d3.select(this).style("fill",getColorForUser(d));
            
            div.transition()		
                .duration(500)		
                .style("opacity", 0);	
        });
        
      // Add a label.
      /*marker.append("text")
          .attr("x", padding + 7)
          .attr("y", padding)
          .attr("dy", ".31em")
          .text(function(d) { return d.value['course']; });*/
          
      function pathTransform(d) {
      

        var t, b, l, r, w, h, currentSvg;
        //$(this).empty(); // get rid of the old lines (cannot use d3 .remove() because i cannot use selectors after ... )
        var radius = 0;
        var dsrc = new google.maps.LatLng(parseFloat(d['y1']), parseFloat(d['x1']));
        var dtrg = new google.maps.LatLng(parseFloat(d['y2']), parseFloat(d['x2']));
        d1 = projection.fromLatLngToDivPixel(dsrc);
        d2 = projection.fromLatLngToDivPixel(dtrg);
        
        if ( d1.y < d2.y ) {
            t = d1.y;
            b = d2.y;
        } else {
            t = d2.y;
            b = d1.y;
        }
        if ( d1.x < d2.x ) {
            l = d1.x;
            r = d2.x;
        } else {
            l = d2.x;
            r = d1.x; 
        }
        currentSvg = d3.select(this)

            .style("left", (l + radius) + "px")
            .style("top", (t + radius) + "px")
            .style("width", (r - l - radius) + "px")
            .style("height", (b - t - radius) + "px");
    // drawing the diagonal lines inside the svg elements. We could use 2 cases instead of for but maybe you will need to orient your graph (so you can use some arrows)
    if (( d1.y < d2.y) && ( d1.x < d2.x)) {
        currentSvg.append("svg:line")
            .style("stroke-width", 1)
            .style("stroke", "black")
            .attr("y1", 0)
            .attr("x1", 0)
            .attr("x2", r-l)
            .attr("y2", b-t);
        } else if ((d1.x > d2.x) && (d1.y > d2.y)){
        currentSvg.append("svg:line")
            .style("stroke-width", 1)
            .style("stroke", "black")
            .attr("y1", 0)
            .attr("x1", 0)
            .attr("x2", r-l)
            .attr("y2", b-t);
        } else if (( d1.y < d2.y) && ( d1.x > d2.x)){
            currentSvg.append("svg:line")
                .style("stroke-width", 1)
                .style("stroke", "black")
                .attr("y1", 0)
                .attr("x2", 0)
                .attr("x1", r-l)
                .attr("y2", b-t);
            } else { //if ((d1.x < d2.x) && (d1.y > d2.y)){
            currentSvg.append("svg:line")
                .style("stroke-width", 1)
                .style("stroke", "black")
                .attr("y1", 0)
                .attr("x2", 0)
                .attr("x1", r-l)
                .attr("y2", b-t);
            } //else {
            //console.log("something is wrong!!!");
           // }


        return currentSvg;
      }

      function transform(d) {
      
        var wh = "12px"
        var padding = 6;
      
        if (("id" in d.value)) {
            if(document.getElementById("radius").checked) {
            var ct = {lat: parseFloat(d.value['lat']), lng: parseFloat(d.value['lon'])};

               // Add circle overlay and bind to marker
                var clusterCircle = new google.maps.Circle({
              strokeColor: '#FF0000',
              strokeOpacity: 0.5,
              strokeWeight: 1,
              fillColor: '#CC4444',
              fillOpacity: 0.06,
              map: map,
              center: ct,
              radius: 200.0//Math.ceil(parseFloat(d.value['med_dist']))
            });
            cluster_circle.push(clusterCircle);
            }
            wh = "30px"
            padding = 15;
            
        }
        
        d = new google.maps.LatLng(parseFloat(d.value['lat']), parseFloat(d.value['lon']));
        d = projection.fromLatLngToDivPixel(d);
        
        
        
        return d3.select(this)
            .style("left", (d.x - padding) + "px")
            .style("top", (d.y - padding) + "px")
            .style("width", wh)
            .style("height", wh);
      }
    };
  };

  // Bind our overlay to the map…
  cluster_overlay.setMap(map);
       

};



function updateRadius() {
    if(document.getElementById("radius").checked == false) {
        cluster_circle.forEach(function(cl) {
            cl.setMap(null);
            cl = null;
        });
        cluster_circle = [];
    }
    cluster_overlay.draw();
};




function clearlayer() {
student_overlay.setMap(null);
};


</script>
    
  </body>
</html>
